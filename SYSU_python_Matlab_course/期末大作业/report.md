## 人工智能编程语言期末报告

摘要：

我们通过图形和文字，详细描述了遗传算法的实现步骤和过程。在描述过程中，本文提供了流程图，基因编码交叉、变异图等。接下来，我们提供了Python和Matlab两种语言对于遗传算法的实现。在网上许多的遗传算法代码实现中，都可以有效的实现并可视化遗传算法过程。然而，大部分现有的实现忽略了遗传算法中不同参数的横向对比实验，为了填补这一空白，我们提供了6组不同的数据，从而可以很好地对遗传算法进行消融实验。

题目要求：

问题1：根据题目的提示画出遗传算法的流程图。问题2：根据题目提供的编码方式，给予实现，并验证结果。问题3：根据题目的提示，在问题2的基础上完成交叉操作。问题4：基于问题2和问题3的结果完成变异操作。问题5：用Python和Matlab实现该算法并给出代码，画出不同参数设置下迭代过程中的最优解变化趋势曲线，然后观察不同参数对算法性能的影响，以及观察每次运行获得的最优解是否一致。写出对实现过程的心得体会。

**问题求解：**

问题一：

遗传算法流程图如图所示

<img src="E:\SYSU\2022第一学期\人工智能编程语言\期末大作业\流程图.png" alt="流程图" style="zoom:33%;" />

问题2：

为了避免于题目造成重复，这里使用以下函数作为问题2至问题4的例子。

$f(x)=\frac{x}{e^{x}} \ \ \ x \in[0,2)$

假设首次生成的初始种群中的x值为

$ x = [1.31, 1.56, 0.23, 0.99, 1.98, 1.01] $ 

此时按照题目要求的编码方式，即对[0,2)的数字进行9位数的二进制编码，其中第一位表示个位的二进制，为0或1，第二位至第五位为十分位编码，第六位至第九位为百分位编码。

通过程序或者直接计算，我们可以得到x序列的编码结果：

$\begin{array}{l}
1.31 \Rightarrow 100110001 \\
1.56 \Rightarrow 101010110 \\
0.23 \Rightarrow 000100011 \\
0.99 \Rightarrow 010011001 \\
1.98 \Rightarrow 110011000 \\
1.01 \Rightarrow 100000001
\end{array}$

得到编码之后，我们可以通过程序或直接计算，重新得到原来的x序列

$\begin{array}{l}
100110001 \Rightarrow 1.31 \\
101010110 \Rightarrow 1.56 \\
000100011 \Rightarrow 0.23\\
010011001  \Rightarrow 0.99\\
110011000  \Rightarrow 1.98\\
100000001 \Rightarrow 1.01
\end{array}$

由此，这种编码方式的正确性得证。

**问题三：**

现在我们在(3)中挑选两个横坐标值作为例子进行交叉操作，这里我们选择的横坐标如(5)所示。

$\begin{array}{l}
x : 1.56 \Rightarrow 101010110 \\
y : 0.23 \Rightarrow 000100011 \\
\end{array}$

如何符合发生交叉的条件，在Python实现的遗传算法中，我们在二进制编码中随机生成两个下标start和end，表示x,y染色体对区间[start,end)中间的基因进行交叉互换。假设对于(5)的两个染色体，随机生成的start,end分别为1和3，则交叉互换后的结果如(6)所示。

$\begin{array}{l}
x’ : 0.16 \Rightarrow 000|010110 \\
y' : 1.63 \Rightarrow 101|100011 \\
\end{array}$

在Matlab实现的遗传算法中，我们在二进制编码中随机生成一个下标start，表示x,y染色体对区间[start,end]部分的基因进行交叉互换，其中end表示染色体末尾。假设对于(5)的两个染色体，随机生成的start分别为3，则交叉互换后的结果如(7)所示。

$\begin{array}{l}
x’ : 1.63 \Rightarrow 101|100011 \\
y' : 0.16 \Rightarrow 000|010110 \\
\end{array}$

以上即为交叉互换过程。

**问题四：**

下面我们将用(8)作为例子演示变异操作。

$\begin{array}{l}
0.99 \Rightarrow 010011001 \\
\end{array}$

如何符合发生变异的条件，在代码实现中，我们在二进制编码长度范围内随机生成一个下标idx，表示要发生变异的位置。然后对idx位置的基因进行反转。假设(8)中随机生成的下标为1，则变异后的染色体为(9)所示。

$\begin{array}{l}
110011001 \Rightarrow 1.99 \\
\end{array}$

以上即为变异过程。





### 结果分析和总结

通过Python实现和Matlab实现的遗传算法的优化结果和消融实验结果，我们可以得出如下结论。

**遗传算法初始参数对优化结果的影响**

1. 在其余参数相同的情况下，迭代次数（Gen）越大，越能得到完全收敛后的结果。如果迭代次数小，会造成优化算法欠拟合的情况出现，而迭代次数过多的时候，则会导致时间上的浪费。
2. 在其余参数相同的情况下，种群整体大小（P和P0）越大，越能保证优化算法得到正确的结果。如果种群整体大小过小，首先，在某些情况下，容易导致优化算法陷入局部最优（例如处理函数g(x)的情况）。其次，种群整体大小过小，容易导致优化结果不稳定，最后难以收敛，如Figure4和Figure6所示。其三，种群大小过小，会导致每次迭代过程中适应度高的个体的出现更加困难，会严重影响函数的优化性能和结果。
3. 在其余参数相同的情况下，一定概率的变异率（pm）可以保证遗传算法在多极值的函数图像上跳出局部最优。如Figure6所示，优化算法在处理g(x)的时候陷入了局部最优，最后没能优化出正确的答案。与此同时，对于函数f(x)，变异率的高低并没有对优化造成很大程度的影响，因为f(x)在[0,4]内只有一个极值点，优化也不存在出现局部最优的问题。
4. 交叉概率（pc）是遗传算法的关键，它可以保证种群在迭代的过程中，会不断出现适应度高的个体，它模仿了大自然个体之间基因交换的过程。因此交叉概率既不能太高也不能太低。

**待优化函数对优化结果的影响**

除了在报告中的两个函数之外，我们还对其它几个函数进行了测试。结合f(x)和g(x)的结果，我们发现，优化算法优化极值点比较少的函数相比于极值点多的函数更加轻松。例如g(x)，如Figure2所示，它的图形在[0,4]中有多个极大值点，这很容易导致优化陷入局部最优，影响优化最终的稳定性和结果。





### 心得体会

